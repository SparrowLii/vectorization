// MIR for `hex_encode::hex` before PreCodegen

fn hex_encode::hex(_1: u8) -> u8 {
    debug byte => _1;                    // in scope 0 at hex_encode.rs:16:12: 16:16
    let mut _0: u8;                      // return place in scope 0 at hex_encode.rs:16:25: 16:27
    let mut _2: &&[u8];                  // in scope 0 at hex_encode.rs:18:9: 18:14
    let _3: usize;                       // in scope 0 at hex_encode.rs:18:15: 18:28
    let mut _4: u8;                      // in scope 0 at hex_encode.rs:18:15: 18:19
    let mut _5: usize;                   // in scope 0 at hex_encode.rs:18:9: 18:29
    let mut _6: bool;                    // in scope 0 at hex_encode.rs:18:9: 18:29

    bb0: {
        StorageLive(_2);                 // scope 0 at hex_encode.rs:18:9: 18:14
        _2 = const {alloc8: &&[u8]};     // scope 0 at hex_encode.rs:18:9: 18:14
                                         // ty::Const
                                         // + ty: &&[u8]
                                         // + val: Value(Scalar(alloc8))
                                         // mir::Constant
                                         // + span: hex_encode.rs:18:9: 18:14
                                         // + literal: Const { ty: &&[u8], val: Value(Scalar(alloc8)) }
        StorageLive(_3);                 // scope 0 at hex_encode.rs:18:15: 18:28
        StorageLive(_4);                 // scope 0 at hex_encode.rs:18:15: 18:19
        _4 = _1;                         // scope 0 at hex_encode.rs:18:15: 18:19
        _3 = move _4 as usize (Misc);    // scope 0 at hex_encode.rs:18:15: 18:28
        StorageDead(_4);                 // scope 0 at hex_encode.rs:18:27: 18:28
        _5 = const 16_usize;             // scope 0 at hex_encode.rs:18:9: 18:29
        _6 = Lt(_3, _5);                 // scope 0 at hex_encode.rs:18:9: 18:29
        assert(move _6, "index out of bounds: the length is {} but the index is {}", move _5, _3) -> bb1; // scope 0 at hex_encode.rs:18:9: 18:29
    }

    bb1: {
        _0 = (*(*_2))[_3];               // scope 0 at hex_encode.rs:18:9: 18:29
        StorageDead(_3);                 // scope 0 at hex_encode.rs:19:5: 19:6
        StorageDead(_2);                 // scope 0 at hex_encode.rs:19:5: 19:6
        return;                          // scope 0 at hex_encode.rs:19:6: 19:6
    }
}

alloc8 (static: TABLE, size: 16, align: 8) {
    ╾───────alloc9────────╼ 10 00 00 00 00 00 00 00 │ ╾──────╼........
}

alloc9 (size: 16, align: 1) {
    30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66 │ 0123456789abcdef
}
